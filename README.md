# Genitic-Algorithms-In-Java-Basics
The genetic algorithm is a method for solving both constrained and unconstrained optimization problems that is based on natural selection, the process that drives biological evolution. The genetic algorithm repeatedly modifies a population of individual solutions. At each step, the genetic algorithm selects individuals from the current population to be parents and uses them to produce the children for the next generation. Over successive generations, the population "evolves" toward an optimal solution. In this repository we will try to apply genetic algorithms to some of the famous problems - of course there are those who have solved these problems before - we are just shifting our understanding of the working method applied to many of these forms and also the difference between each project between them.

In this project On a solve this list of problemes : 
  1) All Ones : 
              First, let’s review the “all ones” problem, a very basic problem that can be solved using a binary genetic algorithm.The problem isn’t very interesting, but it serves its role as being a simple problem which helps emphasize the fundamental techniques involved. As the name suggests, the problem is simply finding a string which is comprised entirely of ones. So for a string with a length of 5 the best solution would be, “11111”.
  
  2) Robotic Controllers :
              The problem we are going to solve is designing a robotic controller that can use the robots sensors to navigate a robot successfully through a maze. The robot can take four actions: move one-step forward, turn left, turn right, or, rarely, do nothing. The robot also has six sensors: three on the front, one on the left, one on the right and one on the back. The maze we are going to explore is comprised of walls that the robot can’t cross and will have an outlined route,  which we want the robot to follow. Keep in mind that the purpose of this chapter isn’t to train a robot to solve mazes. Our purpose is to automatically program a robot controller with six sensors so that it doesn’t crash into walls; we’re simply using the maze as a complicated environment in which to test our robot controller.
              
   3) Traveling Salesman :
                The problem we will be tackling in this implementation is a typical traveling salesman problem in which we need to optimize a route through a collection of cities. We can generate a number of random cities in 2D space by setting each city to a random x, y position. When finding the distance between two cities we will simply use the shortest length between the cities as the distance.Often, the problem will be more complex than this. In this example we are assuming a direct ideal path exists between each city; this is also known as the “Euclidean distance”. This usually isn’t going to be a typical case as there could be various obstacles making the actual shortest path much longer than the Euclidean distance. We are also assuming that traveling from City-A to City-B takes just as long as traveling from City-B to City-A. Again, in reality this is rarely the case. Often there will be obstacles such as one-way roads that will affect the distance between cities while traveling in a certain direction. An implementation of the traveling salesman problem where the distance between the cities changes depending on the direction is called an asymmetric traveling salesman problem.
